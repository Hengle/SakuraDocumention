---
create: 2024-04-17 18:13
aliases: []
tags: []
---
## 对象模型
- Record：对应 C++ 的 struct/class，简单的记录其信息
- Object：抽象概念，一般为 IObject 子类，默认的 RTTR 服务提供方式，包括 get_type 和 cast
- Interface：特殊的 Record，标记此类为 interface，会尽量进行行为约束（只能有函数），但是==在继承方面不做单链限制==
- Pattern：模式匹配，一般用于在静态代码中替代 Interface 或书写更加脚本亲和的代码，在反射中呈现为一个独立的类目
	- 静态使用：使用编译期检查保证匹配
	- 动态使用：一般配合 IObject 进行使用，通过 RTTR 匹配签名来进行动态装载
	- 脚本使用：通过统一导出范式绑定脚本调用，在调用时包装 Pattern 的 vtable

## RTTR
### 统一类型标识
统一类型标识的作用在于描述复杂类型，比如模板、指针、引用、Array 等，一般来说存储一个类型的信息使用的不是 GUID 而是统一类型标识，可以通过统一类型标识查询具体类型，查询具体类型的过程中==会丢失 Const 修饰符==，同时可能会引发泛型化，大量的泛型化会导致 RTTR 的对象激增，所以应当谨慎使用，通常来说使用场景如下：
1. 需要调用一些特殊函数，但是一般来说可以被避免
2. 需要仅仅使用一个 GUID 来描述类型

但是，考虑以下点：
1. 泛型化的行为可以通过 GenericType + TypeDesc 来联合实现，不必要生产实际对象
2. 泛型化会产生生命周期为 Runtime 的 GUID，这会导致对该 GUID 的误用

因此，更实在的设计是，通常情况使用 TypeDescriptor 来保存类型标识，在需要时，拿到对应的 GenericType，传入 TypeDescriptor 进行函数调用，期间并不产生 GUID 也不产生动态建立的类型

### 反射函数调用模型
函数调用一般分为以下阶段：
1. overload solve，检查合适的重载，规则为
	1. 去 const 修饰符，引用转指针，改行为由外部传入开关匹配
	2. 检查访问级别（public、private、protected）
	3. 不允许类型转换，如果有需要，尽量在外部进行转换，设计时应该避免发生转换的情况，尽量使用 overload 来分配行为
2. invoke，通过检查后，现场将函数指针转换为目标类型，并执行调用，上一步保证了栈结构，只进行无害的 const 和引用转换

还可以只执行 overload solve，直接获取 native 指针来优化后续调用

### 外部行为扩展
对于一些外部的扩展，比如 hash、serialize，提供 extern_method 机制，这些函数将注册进来，以完成 RTTR 系统与具体模块的解耦，对于 Core 内提供的功能，以及 cpp 自带的 operator，提供一个内置的名称表来进行规范