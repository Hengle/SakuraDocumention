---
create: 2024-05-09 22:34
aliases: []
tags: []
---
### RTTR 提供的功能
RTTR 主要是针对 C++ 的语言扩展，提供一定的动态能力以辅助一些框架的运转，我们将需求分为 Editor 和 Rumtime 分开讨论。

Runtime：
 - dynamic_cast 需求，interface 需求
 - proxy 作为 interface 的替代手段，也需要通过 RTTR 提取函数
 - 多态序列化需要通过类型标识建立对象的手段，主要运用场景为资源、网络等
 - 如果引入 GC 系统，需要 RTTR 提供对象的引用信息
 - 一些高层框架的实现（比如 RPC）需要用到无视类似 Proxy 但更加灵活的反射函数调用

Editor:
- Inspector 面板定制等，需要以类型作为联属，这里也是反射功能使用的重灾区
- 资源系统，需要将类型信息序列化
- 一些工具代码，不以对象类型作为条件，而是根据对象特征进行工作
- 进行 Editor 面板 Delegate 绑定，实现数据化的函数调用

### 脚本提供的功能
脚本主要是针对某些特定功能点进行快速开发和调试，同样，我们将其分为 Editor 和 Runtime 来讨论

Runtime：
- 调度 C++ 逻辑，组装高层业务，即 Script Call C++
- 扩展 C++ 类型，让实现一些 C++ 发起调用的逻辑，即 C++ Call Script，这个手段应当具有 Native 风格，是相对克制的
	- Proxy 按照名字从 Script Object 中提取函数
	- ScriptObject 继承 C++ 函数
- 脚本定义的配置或者数据资产，依赖引擎的序列化系统

Editor：
- 扩展界面、工具，脚本的快速开发非常适合 GUI 和工具的开发
- 扩展资产，同时进行资产操作，这也是工具范畴

### 功能交叉点
- 脚本涉入资产决定了资产类型不只是 C++ 的 Native 类型，也需要存储一些由脚本定义的资产
- 脚本摄入 Editor GUI 决定了脚本不只是要扩展脚本书写的类型，也需要扩展 C++ 书写的类型，这要求类型标识有一定的唯一性
- C++ Call Script 的场景也有可能不能预知需要 Call 的是否是 Native 对象，这就需要一个掩盖细节的统一接口

### 如何解决交叉点
- 允许动态扩展 Type，但是遵循 Native 规范，即必须指定一个 GUID，否则不能使用 Native 的类型系统，这解决了类型标识统一性的问题
- 另一种方式是，Native 使用 Native 的方式序列化，脚本使用脚本的方式序列化，不共用类型标识
- Proxy 能够掩盖 C++ Call Scirpt 的细节，且 Proxy 可以由脚本系统主动制造
- 脚本环境可以是 MultiContext 的，这时候类型重复与 RTTR 的全局唯一 Type 机制有冲突

核心矛盾点在于，==脚本是全局作用域还是局部作用域使用==
